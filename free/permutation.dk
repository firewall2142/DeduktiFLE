def injn :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  cts.prod
    cts.box
    cts.star
    cts.star
    cts.I
    nat.nat
    (x:(cts.Term cts.box nat.nat) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x0:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x1:(cts.Term cts.star (nat.le x n)) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x0 n)
             (x2:(cts.Term cts.star (nat.le x0 n)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (f x) (f x0))
                (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) => logic.eq nat.nat x x0))))).

def injn_Sn_n :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.injn x (nat.S x0))
             (x1:(cts.Term cts.star (permutation.injn x (nat.S x0))) => permutation.injn x x0))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  H:(cts.Term
       cts.star
       (cts.prod'
          cts.box
          cts.star
          cts.star
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x (nat.S n))
                (x1:(cts.Term cts.star (nat.le x (nat.S n))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x0 (nat.S n))
                   (x2:(cts.Term cts.star (nat.le x0 (nat.S n))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat (f x) (f x0))
                      (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                       logic.eq nat.nat x x0))))))) =>
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  lei:(cts.Term cts.star (nat.le i n)) =>
  lej:(cts.Term cts.star (nat.le j n)) =>
  eqf:(cts.Term cts.star (logic.eq nat.nat (f i) (f j))) =>
  H
    i
    j
    (nat.le_S i n lei)
    (nat.le_S j n lej)
    (logic.rewrite_l
       nat.nat
       (f i)
       (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f i) __)
       (logic.refl nat.nat (f i))
       (f j)
       eqf).

def permut :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  m:(cts.Term cts.box nat.nat) =>
  connectives.And
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x m)
          (x0:(cts.Term cts.star (nat.le x m)) => nat.le (f x) m)))
    (permutation.injn f m).

def transpose :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  n:(cts.Term cts.box nat.nat) =>
  bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) (nat.eqb n i).

def transpose_i_j_i :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) => logic.eq nat.nat (permutation.transpose x x0 x) x0)))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  logic.eq_ind_r
    bool.bool
    bool.true
    (x:(cts.Term cts.box bool.bool) =>
     logic.eq
       nat.nat
       (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i i (nat.eqb i j)) x)
       j)
    (bool.eq_match_bool_type_true
       nat.nat
       j
       (bool.match_bool_type nat.nat i i (nat.eqb i j))
       (y:(cts.Term cts.box nat.nat) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type nat.nat i i (nat.eqb i j))
             bool.true)
          y)
       (logic.refl
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type nat.nat i i (nat.eqb i j))
             bool.true)))
    (nat.eqb i i)
    (nat.eqb_n_n i).

def transpose_i_j_j :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) => logic.eq nat.nat (permutation.transpose x x0 x0) x)))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb j i) bool.true)
    (logic.eq bool.bool (nat.eqb j i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type nat.nat i j (nat.eqb j j))
          (nat.eqb j i))
       i)
    (Hc:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j (nat.eqb j j)) x)
          i)
       (bool.sym_eq_match_bool_type_true
          nat.nat
          j
          (bool.match_bool_type nat.nat i j (nat.eqb j j))
          (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y i)
          (logic.eq_ind_r
             nat.nat
             i
             (x:(cts.Term cts.box nat.nat) => logic.eq nat.nat x i)
             (logic.refl nat.nat i)
             j
             (nat.eqb_true_to_eq j i Hc)))
       (nat.eqb j i)
       Hc)
    (Hc:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j (nat.eqb j j)) x)
          i)
       (logic.eq_ind_r
          bool.bool
          bool.true
          (x:(cts.Term cts.box bool.bool) =>
           logic.eq
             nat.nat
             (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j x) bool.false)
             i)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             j
             (bool.match_bool_type nat.nat i j bool.true)
             (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y i)
             (bool.eq_match_bool_type_true
                nat.nat
                i
                j
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq nat.nat (bool.match_bool_type nat.nat i j bool.true) y)
                (bool.eq_match_bool_type_false
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i j bool.true)
                   (y:(cts.Term cts.box nat.nat) =>
                    logic.eq nat.nat (bool.match_bool_type nat.nat i j bool.true) y)
                   (bool.eq_match_bool_type_false
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i j bool.true)
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq
                         nat.nat
                         y
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j bool.true)
                            bool.false))
                      (logic.refl
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j bool.true)
                            bool.false))))))
          (nat.eqb j j)
          (nat.eqb_n_n j))
       (nat.eqb j i)
       Hc)
    (bool.true_or_false (nat.eqb j i)).

def transpose_i_j_j_i :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              logic.eq nat.nat (permutation.transpose x x0 x1) (permutation.transpose x0 x x1)))))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  n:(cts.Term cts.box nat.nat) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb n i) bool.true)
    (logic.eq bool.bool (nat.eqb n i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (nat.eqb n i))
       (bool.match_bool_type
          nat.nat
          i
          (bool.match_bool_type nat.nat j n (nat.eqb n i))
          (nat.eqb n j)))
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) x)
          (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n x) (nat.eqb n j)))
       (connectives.match_Or_prop
          (logic.eq bool.bool (nat.eqb n j) bool.true)
          (logic.eq bool.bool (nat.eqb n j) bool.false)
          (logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                bool.true)
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type nat.nat j n bool.true)
                (nat.eqb n j)))
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
           logic.eq_ind_r
             bool.bool
             bool.true
             (x:(cts.Term cts.box bool.bool) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.true)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.true) x))
             (bool.sym_eq_match_bool_type_true
                nat.nat
                j
                (bool.match_bool_type nat.nat i n bool.true)
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   y
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.true)
                      bool.true))
                (bool.sym_eq_match_bool_type_true
                   nat.nat
                   i
                   (bool.match_bool_type nat.nat j n bool.true)
                   (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat j y)
                   (logic.eq_ind
                      nat.nat
                      n
                      (x_1:(cts.Term cts.box nat.nat) => logic.eq nat.nat j x_1)
                      (logic.eq_ind
                         nat.nat
                         n
                         (x_1:(cts.Term cts.box nat.nat) => logic.eq nat.nat x_1 n)
                         (logic.refl nat.nat n)
                         j
                         (nat.eqb_true_to_eq n j Hnj))
                      i
                      (nat.eqb_true_to_eq n i Hni))))
             (nat.eqb n j)
             Hnj)
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
           logic.eq_ind_r
             bool.bool
             bool.false
             (x:(cts.Term cts.box bool.bool) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.true)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.true) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                i
                n
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat j y bool.true)
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.true)
                      bool.false))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   i
                   (bool.match_bool_type nat.nat j n bool.true)
                   (y:(cts.Term cts.box nat.nat) =>
                    logic.eq nat.nat (bool.match_bool_type nat.nat j n bool.true) y)
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      j
                      n
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat j n bool.true) y)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         j
                         n
                         (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y j)
                         (logic.refl nat.nat j)))))
             (nat.eqb n j)
             Hnj)
          (bool.true_or_false (nat.eqb n j)))
       (nat.eqb n i)
       Hni)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) x)
          (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n x) (nat.eqb n j)))
       (connectives.match_Or_prop
          (logic.eq bool.bool (nat.eqb n j) bool.true)
          (logic.eq bool.bool (nat.eqb n j) bool.false)
          (logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                bool.false)
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type nat.nat j n bool.false)
                (nat.eqb n j)))
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
           logic.eq_ind_r
             bool.bool
             bool.true
             (x:(cts.Term cts.box bool.bool) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.false)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.false) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                j
                (bool.match_bool_type nat.nat i n bool.true)
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   y
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.false)
                      bool.true))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   j
                   n
                   (y:(cts.Term cts.box nat.nat) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type nat.nat i n bool.true)
                      (bool.match_bool_type nat.nat i y bool.true))
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      i
                      n
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat i n bool.true) y)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         i
                         n
                         (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y i)
                         (logic.refl nat.nat i)))))
             (nat.eqb n j)
             Hnj)
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
           logic.eq_ind_r
             bool.bool
             bool.false
             (x:(cts.Term cts.box bool.bool) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.false)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.false) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                i
                n
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat j y bool.false)
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.false)
                      bool.false))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   j
                   n
                   (y:(cts.Term cts.box nat.nat) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type nat.nat j n bool.false)
                      (bool.match_bool_type nat.nat i y bool.false))
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      j
                      n
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq nat.nat y (bool.match_bool_type nat.nat i n bool.false))
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         i
                         n
                         (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat n y)
                         (logic.refl nat.nat n)))))
             (nat.eqb n j)
             Hnj)
          (bool.true_or_false (nat.eqb n j)))
       (nat.eqb n i)
       Hni)
    (bool.true_or_false (nat.eqb n i)).

def transpose_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              logic.eq nat.nat (permutation.transpose x x0 (permutation.transpose x x0 x1)) x1))))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  n:(cts.Term cts.box nat.nat) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb n i) bool.true)
    (logic.eq bool.bool (nat.eqb n i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type
             nat.nat
             i
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (nat.eqb n i))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   (nat.eqb n i))
                j))
          (nat.eqb
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (nat.eqb n i))
             i))
       n)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                (nat.eqb
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      x)
                   j))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                i))
          n)
       (bool.sym_eq_match_bool_type_true
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (y:(cts.Term cts.box nat.nat) =>
           logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type
                   nat.nat
                   i
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      bool.true)
                   (nat.eqb
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.true)
                      j))
                (nat.eqb y i))
             n)
          (bool.sym_eq_match_bool_type_true
             nat.nat
             j
             (bool.match_bool_type nat.nat i n (nat.eqb n j))
             (y:(cts.Term cts.box nat.nat) =>
              logic.eq
                nat.nat
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.true)
                      (nat.eqb y j))
                   (nat.eqb j i))
                n)
             (bool.sym_eq_match_bool_type_true
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i y (nat.eqb j j))
                      (nat.eqb j i))
                   n)
                (connectives.match_Or_prop
                   (logic.eq bool.bool (nat.eqb j i) bool.true)
                   (logic.eq bool.bool (nat.eqb j i) bool.false)
                   (logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (nat.eqb j i))
                      n)
                   (Hji:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.true)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.true
                      (x:(cts.Term cts.box bool.bool) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j (nat.eqb j j))
                            x)
                         n)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y n)
                         (logic.eq_ind_r
                            nat.nat
                            i
                            (x:(cts.Term cts.box nat.nat) => logic.eq nat.nat j x)
                            (nat.eqb_true_to_eq j i Hji)
                            n
                            (nat.eqb_true_to_eq n i Hni)))
                      (nat.eqb j i)
                      Hji)
                   (Hji:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.false)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.false
                      (x:(cts.Term cts.box bool.bool) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j (nat.eqb j j))
                            x)
                         n)
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y n)
                         (logic.eq_ind_r
                            bool.bool
                            bool.true
                            (x:(cts.Term cts.box bool.bool) =>
                             logic.eq nat.nat (bool.match_bool_type nat.nat i j x) n)
                            (bool.sym_eq_match_bool_type_true
                               nat.nat
                               i
                               j
                               (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y n)
                               (logic.sym_eq nat.nat n i (nat.eqb_true_to_eq n i Hni)))
                            (nat.eqb j j)
                            (nat.eqb_n_n j)))
                      (nat.eqb j i)
                      Hji)
                   (bool.true_or_false (nat.eqb j i))))))
       (nat.eqb n i)
       Hni)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term cts.box bool.bool) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                (nat.eqb
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      x)
                   j))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                i))
          n)
       (bool.sym_eq_match_bool_type_false
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (y:(cts.Term cts.box nat.nat) =>
           logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type
                   nat.nat
                   i
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      bool.false)
                   (nat.eqb
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.false)
                      j))
                (nat.eqb y i))
             n)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             j
             (bool.match_bool_type nat.nat i n (nat.eqb n j))
             (y:(cts.Term cts.box nat.nat) =>
              logic.eq
                nat.nat
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.false)
                      (nat.eqb y j))
                   (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                n)
             (bool.sym_eq_match_bool_type_false
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (y:(cts.Term cts.box nat.nat) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type
                         nat.nat
                         i
                         y
                         (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) j))
                      (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                   n)
                (connectives.match_Or_prop
                   (logic.eq bool.bool (nat.eqb n j) bool.true)
                   (logic.eq bool.bool (nat.eqb n j) bool.false)
                   (logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type
                            nat.nat
                            i
                            (bool.match_bool_type nat.nat i n (nat.eqb n j))
                            (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) j))
                         (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                      n)
                   (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.true
                      (x:(cts.Term cts.box bool.bool) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type
                               nat.nat
                               i
                               (bool.match_bool_type nat.nat i n x)
                               (nat.eqb (bool.match_bool_type nat.nat i n x) j))
                            (nat.eqb (bool.match_bool_type nat.nat i n x) i))
                         n)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         i
                         n
                         (y:(cts.Term cts.box nat.nat) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type
                                  nat.nat
                                  i
                                  (bool.match_bool_type nat.nat i n bool.true)
                                  (nat.eqb (bool.match_bool_type nat.nat i n bool.true) j))
                               (nat.eqb y i))
                            n)
                         (bool.sym_eq_match_bool_type_true
                            nat.nat
                            i
                            n
                            (y:(cts.Term cts.box nat.nat) =>
                             logic.eq
                               nat.nat
                               (bool.match_bool_type
                                  nat.nat
                                  j
                                  (bool.match_bool_type
                                     nat.nat
                                     i
                                     (bool.match_bool_type nat.nat i n bool.true)
                                     (nat.eqb y j))
                                  (nat.eqb i i))
                               n)
                            (bool.sym_eq_match_bool_type_true
                               nat.nat
                               i
                               n
                               (y:(cts.Term cts.box nat.nat) =>
                                logic.eq
                                  nat.nat
                                  (bool.match_bool_type
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i y (nat.eqb i j))
                                     (nat.eqb i i))
                                  n)
                               (logic.eq_ind_r
                                  bool.bool
                                  bool.true
                                  (x:(cts.Term cts.box bool.bool) =>
                                   logic.eq
                                     nat.nat
                                     (bool.match_bool_type
                                        nat.nat
                                        j
                                        (bool.match_bool_type nat.nat i i (nat.eqb i j))
                                        x)
                                     n)
                                  (bool.sym_eq_match_bool_type_true
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i i (nat.eqb i j))
                                     (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y n)
                                     (logic.sym_eq
                                        nat.nat
                                        n
                                        j
                                        (nat.eqb_true_to_eq n j Hnj)))
                                  (nat.eqb i i)
                                  (nat.eqb_n_n i)))))
                      (nat.eqb n j)
                      Hnj)
                   (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.false
                      (x:(cts.Term cts.box bool.bool) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type
                               nat.nat
                               i
                               (bool.match_bool_type nat.nat i n x)
                               (nat.eqb (bool.match_bool_type nat.nat i n x) j))
                            (nat.eqb (bool.match_bool_type nat.nat i n x) i))
                         n)
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         i
                         n
                         (y:(cts.Term cts.box nat.nat) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type
                                  nat.nat
                                  i
                                  (bool.match_bool_type nat.nat i n bool.false)
                                  (nat.eqb (bool.match_bool_type nat.nat i n bool.false) j))
                               (nat.eqb y i))
                            n)
                         (bool.sym_eq_match_bool_type_false
                            nat.nat
                            i
                            n
                            (y:(cts.Term cts.box nat.nat) =>
                             logic.eq
                               nat.nat
                               (bool.match_bool_type
                                  nat.nat
                                  j
                                  (bool.match_bool_type
                                     nat.nat
                                     i
                                     (bool.match_bool_type nat.nat i n bool.false)
                                     (nat.eqb y j))
                                  (nat.eqb n i))
                               n)
                            (bool.sym_eq_match_bool_type_false
                               nat.nat
                               i
                               n
                               (y:(cts.Term cts.box nat.nat) =>
                                logic.eq
                                  nat.nat
                                  (bool.match_bool_type
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i y (nat.eqb n j))
                                     (nat.eqb n i))
                                  n)
                               (logic.eq_ind_r
                                  bool.bool
                                  bool.false
                                  (x:(cts.Term cts.box bool.bool) =>
                                   logic.eq
                                     nat.nat
                                     (bool.match_bool_type
                                        nat.nat
                                        j
                                        (bool.match_bool_type nat.nat i n (nat.eqb n j))
                                        x)
                                     n)
                                  (logic.eq_ind_r
                                     bool.bool
                                     bool.false
                                     (x:(cts.Term cts.box bool.bool) =>
                                      logic.eq
                                        nat.nat
                                        (bool.match_bool_type
                                           nat.nat
                                           j
                                           (bool.match_bool_type nat.nat i n x)
                                           bool.false)
                                        n)
                                     (bool.eq_match_bool_type_false
                                        nat.nat
                                        i
                                        n
                                        (y:(cts.Term cts.box nat.nat) =>
                                         logic.eq
                                           nat.nat
                                           (bool.match_bool_type
                                              nat.nat
                                              j
                                              (bool.match_bool_type
                                                 nat.nat
                                                 i
                                                 n
                                                 bool.false)
                                              bool.false)
                                           y)
                                        (bool.eq_match_bool_type_false
                                           nat.nat
                                           j
                                           (bool.match_bool_type nat.nat i n bool.false)
                                           (y:(cts.Term cts.box nat.nat) =>
                                            logic.eq
                                              nat.nat
                                              (bool.match_bool_type
                                                 nat.nat
                                                 j
                                                 (bool.match_bool_type
                                                    nat.nat
                                                    i
                                                    n
                                                    bool.false)
                                                 bool.false)
                                              y)
                                           (logic.refl
                                              nat.nat
                                              (bool.match_bool_type
                                                 nat.nat
                                                 j
                                                 (bool.match_bool_type
                                                    nat.nat
                                                    i
                                                    n
                                                    bool.false)
                                                 bool.false))))
                                     (nat.eqb n j)
                                     Hnj)
                                  (nat.eqb n i)
                                  Hni))))
                      (nat.eqb n j)
                      Hnj)
                   (bool.true_or_false (nat.eqb n j))))))
       (nat.eqb n i)
       Hni)
    (bool.true_or_false (nat.eqb n i)).

def injective_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           relations.injective_ nat.nat nat.nat (permutation.transpose x x0))))
  :=
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  x:(cts.Term cts.box nat.nat) =>
  y:(cts.Term cts.box nat.nat) =>
  auto:(cts.Term
          cts.star
          (logic.eq nat.nat (permutation.transpose i j x) (permutation.transpose i j y))) =>
  logic.rewrite_r
    nat.nat
    y
    (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat __ y)
    (logic.refl nat.nat y)
    x
    (logic.rewrite_l
       nat.nat
       (permutation.transpose i j (permutation.transpose i j x))
       (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat __ y)
       (logic.rewrite_r
          nat.nat
          (permutation.transpose i j y)
          (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (permutation.transpose i j __) y)
          (permutation.transpose_transpose i j y)
          (permutation.transpose i j x)
          auto)
       x
       (permutation.transpose_transpose i j x)).

def permut_S_to_permut_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x (nat.S x0))
             (x1:(cts.Term cts.star (permutation.permut x (nat.S x0))) =>
              permutation.permut
                (n:(cts.Term cts.box nat.nat) =>
                 permutation.transpose (x (nat.S x0)) (nat.S x0) (x n))
                x0))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  m:(cts.Term cts.box nat.nat) =>
  _clearme:(cts.Term
              cts.star
              (connectives.And
                 (cts.prod
                    cts.box
                    cts.star
                    cts.star
                    cts.I
                    nat.nat
                    (x:(cts.Term cts.box nat.nat) =>
                     cts.prod
                       cts.star
                       cts.star
                       cts.star
                       cts.I
                       (nat.le x (nat.S m))
                       (x0:(cts.Term cts.star (nat.le x (nat.S m))) => nat.le (f x) (nat.S m))))
                 (permutation.injn f (nat.S m)))) =>
  connectives.match_And_prop
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x (nat.S m))
          (x0:(cts.Term cts.star (nat.le x (nat.S m))) => nat.le (f x) (nat.S m))))
    (permutation.injn f (nat.S m))
    (permutation.permut
       (n:(cts.Term cts.box nat.nat) => permutation.transpose (f (nat.S m)) (nat.S m) (f n))
       m)
    (permf1:(cts.Term
               cts.star
               (cts.prod'
                  cts.box
                  cts.star
                  cts.star
                  nat.nat
                  (x:(cts.Term cts.box nat.nat) =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (nat.le x (nat.S m))
                     (x0:(cts.Term cts.star (nat.le x (nat.S m))) => nat.le (f x) (nat.S m))))) =>
     permf2:(cts.Term
               cts.star
               (cts.prod'
                  cts.box
                  cts.star
                  cts.star
                  nat.nat
                  (x:(cts.Term cts.box nat.nat) =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat.nat
                     (x0:(cts.Term cts.box nat.nat) =>
                      cts.prod
                        cts.star
                        cts.star
                        cts.star
                        cts.I
                        (nat.le x (nat.S m))
                        (x1:(cts.Term cts.star (nat.le x (nat.S m))) =>
                         cts.prod
                           cts.star
                           cts.star
                           cts.star
                           cts.I
                           (nat.le x0 (nat.S m))
                           (x2:(cts.Term cts.star (nat.le x0 (nat.S m))) =>
                            cts.prod
                              cts.star
                              cts.star
                              cts.star
                              cts.I
                              (logic.eq nat.nat (f x) (f x0))
                              (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                               logic.eq nat.nat x x0))))))) =>
     connectives.conj
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x m)
             (x0:(cts.Term cts.star (nat.le x m)) =>
              nat.le (permutation.transpose (f (nat.S m)) (nat.S m) (f x)) m)))
       (permutation.injn
          (n:(cts.Term cts.box nat.nat) => permutation.transpose (f (nat.S m)) (nat.S m) (f n))
          m)
       (i:(cts.Term cts.box nat.nat) =>
        leim:(cts.Term cts.star (nat.le i m)) =>
        logic.eq_ind_r
          bool.bool
          bool.false
          (x:(cts.Term cts.box bool.bool) =>
           nat.le
             (bool.match_bool_type
                nat.nat
                (nat.S m)
                (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
                x)
             m)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             (nat.S m)
             (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
             (y:(cts.Term cts.box nat.nat) => nat.le y m)
             (connectives.match_Or_prop
                (nat.lt (f i) (nat.S m))
                (logic.eq nat.nat (f i) (nat.S m))
                (nat.le
                   (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
                   m)
                (Hfi:(cts.Term cts.star (nat.le (nat.S (f i)) (nat.S m))) =>
                 logic.eq_ind_r
                   bool.bool
                   bool.false
                   (x:(cts.Term cts.box bool.bool) =>
                    nat.le (bool.match_bool_type nat.nat (f (nat.S m)) (f i) x) m)
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      (f (nat.S m))
                      (f i)
                      (y:(cts.Term cts.box nat.nat) => nat.le y m)
                      (nat.le_S_S_to_le (f i) m Hfi))
                   (nat.eqb (f i) (nat.S m))
                   (nat.not_eq_to_eqb_false
                      (f i)
                      (nat.S m)
                      (nat.lt_to_not_eq (f i) (nat.S m) Hfi)))
                (Hfi:(cts.Term cts.star (logic.eq nat.nat (f i) (nat.S m))) =>
                 logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term cts.box bool.bool) =>
                    nat.le (bool.match_bool_type nat.nat (f (nat.S m)) (f i) x) m)
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      (f (nat.S m))
                      (f i)
                      (y:(cts.Term cts.box nat.nat) => nat.le y m)
                      (connectives.match_Or_prop
                         (nat.lt (f (nat.S m)) (nat.S m))
                         (logic.eq nat.nat (f (nat.S m)) (nat.S m))
                         (nat.le (f (nat.S m)) m)
                         (H:(cts.Term cts.star (nat.le (nat.S (f (nat.S m))) (nat.S m))) =>
                          nat.le_S_S_to_le (f (nat.S m)) m H)
                         (H:(cts.Term cts.star (logic.eq nat.nat (f (nat.S m)) (nat.S m))) =>
                          connectives.falsity
                            (nat.le (f (nat.S m)) m)
                            (logic.absurd
                               (logic.eq nat.nat i (nat.S m))
                               (permf2
                                  i
                                  (nat.S m)
                                  (nat.le_S i m leim)
                                  (nat.le_n (nat.S m))
                                  (logic.rewrite_l
                                     nat.nat
                                     (f i)
                                     (__:(cts.Term cts.box nat.nat) =>
                                      logic.eq nat.nat (f i) (f __))
                                     (logic.rewrite_r
                                        nat.nat
                                        (f i)
                                        (__:(cts.Term cts.box nat.nat) =>
                                         logic.eq nat.nat (f i) __)
                                        (logic.refl nat.nat (f i))
                                        (f (f i))
                                        (logic.rewrite_r
                                           nat.nat
                                           (nat.S m)
                                           (__:(cts.Term cts.box nat.nat) =>
                                            logic.eq nat.nat (f (f i)) __)
                                           (logic.rewrite_r
                                              nat.nat
                                              (nat.S m)
                                              (__:(cts.Term cts.box nat.nat) =>
                                               logic.eq nat.nat (f __) (nat.S m))
                                              H
                                              (f i)
                                              Hfi)
                                           (f i)
                                           Hfi))
                                     (nat.S m)
                                     Hfi))
                               (logic.not_to_not
                                  (logic.eq nat.nat i (nat.S m))
                                  (nat.le (nat.S m) m)
                                  (auto:(cts.Term
                                           cts.star
                                           (logic.eq nat.nat i (nat.S m))) =>
                                   logic.eq_coerc
                                     (nat.le i m)
                                     (nat.le (nat.S m) m)
                                     leim
                                     (logic.rewrite_l
                                        nat.nat
                                        i
                                        (__:(cts.Term cts.box nat.nat) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (nat.le i m)
                                           (nat.le __ m))
                                        (logic.refl
                                           (cts.univ cts.star cts.box cts.I)
                                           (nat.le i m))
                                        (nat.S m)
                                        auto))
                                  (nat.lt_to_not_le m (nat.S m) (nat.le_n (nat.S m))))))
                         (nat.le_to_or_lt_eq
                            (f (nat.S m))
                            (nat.S m)
                            (permf1 (nat.S m) (nat.le_n (nat.S m))))))
                   (nat.eqb (f i) (nat.S m))
                   (nat.eq_to_eqb_true (f i) (nat.S m) Hfi))
                (nat.le_to_or_lt_eq (f i) (nat.S m) (permf1 i (nat.le_S i m leim)))))
          (nat.eqb (f i) (f (nat.S m)))
          (nat.not_eq_to_eqb_false
             (f i)
             (f (nat.S m))
             (connectives.nmk
                (logic.eq nat.nat (f i) (f (nat.S m)))
                (H:(cts.Term cts.star (logic.eq nat.nat (f i) (f (nat.S m)))) =>
                 logic.absurd
                   (logic.eq nat.nat i (nat.S m))
                   (permf2 i (nat.S m) (nat.le_S i m leim) (nat.le_n (nat.S m)) H)
                   (nat.lt_to_not_eq i (nat.S m) (nat.le_S_S i m leim))))))
       (a:(cts.Term cts.box nat.nat) =>
        b:(cts.Term cts.box nat.nat) =>
        leam:(cts.Term cts.star (nat.le a m)) =>
        lebm:(cts.Term cts.star (nat.le b m)) =>
        H:(cts.Term
             cts.star
             (logic.eq
                nat.nat
                ((n:(cts.Term cts.box nat.nat) =>
                  permutation.transpose (f (nat.S m)) (nat.S m) (f n))
                   a)
                ((n:(cts.Term cts.box nat.nat) =>
                  permutation.transpose (f (nat.S m)) (nat.S m) (f n))
                   b))) =>
        permf2
          a
          b
          (nat.le_S a m leam)
          (nat.le_S b m lebm)
          (permutation.injective_transpose (f (nat.S m)) (nat.S m) (f a) (f b) H)))
    _clearme.

def bijn :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  cts.prod
    cts.box
    cts.star
    cts.star
    cts.I
    nat.nat
    (x:(cts.Term cts.box nat.nat) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (nat.le x n)
       (x0:(cts.Term cts.star (nat.le x n)) =>
        connectives.ex
          nat.nat
          (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) x)))).

def eq_to_bijn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat))
          (x0:(cts.Term
                 cts.box
                 (cts.prod
                    cts.box
                    cts.box
                    cts.box
                    cts.I
                    nat.nat
                    (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x2:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x1)
                      (x3:(cts.Term cts.star (nat.le x2 x1)) => logic.eq nat.nat (x x2) (x0 x2))))
                (x2:(cts.Term
                       cts.star
                       (cts.prod
                          cts.box
                          cts.star
                          cts.star
                          cts.I
                          nat.nat
                          (x2:(cts.Term cts.box nat.nat) =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x2 x1)
                             (x3:(cts.Term cts.star (nat.le x2 x1)) =>
                              logic.eq nat.nat (x x2) (x0 x2))))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.bijn x x1)
                   (x3:(cts.Term cts.star (permutation.bijn x x1)) => permutation.bijn x0 x1))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  g:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  H:(cts.Term
       cts.star
       (cts.prod'
          cts.box
          cts.star
          cts.star
          nat.nat
          (x2:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x2 n)
             (x3:(cts.Term cts.star (nat.le x2 n)) => logic.eq nat.nat (f x2) (g x2))))) =>
  bijf:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x n)
                (x0:(cts.Term cts.star (nat.le x n)) =>
                 connectives.ex
                   nat.nat
                   (p:(cts.Term cts.box nat.nat) =>
                    connectives.And (nat.le p n) (logic.eq nat.nat (f p) x)))))) =>
  i:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (connectives.ex
       nat.nat
       (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (g p) i)))
    (a:(cts.Term cts.box nat.nat) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (connectives.ex
          nat.nat
          (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (g p) i)))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term cts.box nat.nat) => connectives.And (nat.le x n) (logic.eq nat.nat (g x) i))
          a
          (connectives.conj
             (nat.le a n)
             (logic.eq nat.nat (g a) i)
             lean
             (logic.eq_ind
                nat.nat
                (f a)
                (x_1:(cts.Term cts.box nat.nat) => logic.eq nat.nat (g a) x_1)
                (logic.sym_eq nat.nat (f a) (g a) (H a lean))
                i
                fa)))
       _clearme)
    (bijf i lein).

def bijn_n_Sn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.bijn x x0)
             (x1:(cts.Term cts.star (permutation.bijn x x0)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (x (nat.S x0)) (nat.S x0))
                (x2:(cts.Term cts.star (logic.eq nat.nat (x (nat.S x0)) (nat.S x0))) =>
                 permutation.bijn x (nat.S x0))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  bijf:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x n)
                (x0:(cts.Term cts.star (nat.le x n)) =>
                 connectives.ex
                   nat.nat
                   (p:(cts.Term cts.box nat.nat) =>
                    connectives.And (nat.le p n) (logic.eq nat.nat (f p) x)))))) =>
  fS:(cts.Term cts.star (logic.eq nat.nat (f (nat.S n)) (nat.S n))) =>
  i:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i (nat.S n))) =>
  connectives.match_Or_prop
    (nat.lt i (nat.S n))
    (logic.eq nat.nat i (nat.S n))
    (connectives.ex
       nat.nat
       (p:(cts.Term cts.box nat.nat) =>
        connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
    (Hi:(cts.Term cts.star (nat.le (nat.S i) (nat.S n))) =>
     connectives.match_ex_prop
       nat.nat
       (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
       (connectives.ex
          nat.nat
          (p:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
       (a:(cts.Term cts.box nat.nat) =>
        _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
        connectives.match_And_prop
          (nat.le a n)
          (logic.eq nat.nat (f a) i)
          (connectives.ex
             nat.nat
             (p:(cts.Term cts.box nat.nat) =>
              connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
          (lean:(cts.Term cts.star (nat.le a n)) =>
           fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
           connectives.ex_intro
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              connectives.And (nat.le x (nat.S n)) (logic.eq nat.nat (f x) i))
             a
             (connectives.conj
                (nat.le a (nat.S n))
                (logic.eq nat.nat (f a) i)
                (nat.le_S a n lean)
                (logic.rewrite_r
                   nat.nat
                   i
                   (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat __ i)
                   (logic.refl nat.nat i)
                   (f a)
                   fa)))
          _clearme)
       (bijf i (nat.le_S_S_to_le i n Hi)))
    (Hi:(cts.Term cts.star (logic.eq nat.nat i (nat.S n))) =>
     connectives.ex_intro
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        connectives.And (nat.le x (nat.S n)) (logic.eq nat.nat (f x) i))
       i
       (connectives.conj
          (nat.le i (nat.S n))
          (logic.eq nat.nat (f i) i)
          (logic.eq_coerc
             (nat.le i i)
             (nat.le i (nat.S n))
             (nat.le_n i)
             (logic.rewrite_l
                nat.nat
                i
                (__:(cts.Term cts.box nat.nat) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (nat.le i i) (nat.le i __))
                (logic.refl (cts.univ cts.star cts.box cts.I) (nat.le i i))
                (nat.S n)
                Hi))
          (logic.rewrite_r
             nat.nat
             i
             (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat __ i)
             (logic.refl nat.nat i)
             (f i)
             (logic.rewrite_r
                nat.nat
                (nat.S n)
                (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f i) __)
                (logic.rewrite_r
                   nat.nat
                   (nat.S n)
                   (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f __) (nat.S n))
                   fS
                   i
                   Hi)
                i
                Hi))))
    (nat.le_to_or_lt_eq i (nat.S n) lein).

def bijn_fg :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat))
          (x0:(cts.Term
                 cts.box
                 (cts.prod
                    cts.box
                    cts.box
                    cts.box
                    cts.I
                    nat.nat
                    (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (permutation.bijn x x1)
                (x2:(cts.Term cts.star (permutation.bijn x x1)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.bijn x0 x1)
                   (x3:(cts.Term cts.star (permutation.bijn x0 x1)) =>
                    permutation.bijn (p:(cts.Term cts.box nat.nat) => x (x0 p)) x1))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  g:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  bijf:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x n)
                (x0:(cts.Term cts.star (nat.le x n)) =>
                 connectives.ex
                   nat.nat
                   (p:(cts.Term cts.box nat.nat) =>
                    connectives.And (nat.le p n) (logic.eq nat.nat (f p) x)))))) =>
  bijg:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x n)
                (x0:(cts.Term cts.star (nat.le x n)) =>
                 connectives.ex
                   nat.nat
                   (p:(cts.Term cts.box nat.nat) =>
                    connectives.And (nat.le p n) (logic.eq nat.nat (g p) x)))))) =>
  i:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (connectives.ex
       nat.nat
       (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
    (a:(cts.Term cts.box nat.nat) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (connectives.ex
          nat.nat
          (p:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        ga:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.match_ex_prop
          nat.nat
          (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (g p) a))
          (connectives.ex
             nat.nat
             (p:(cts.Term cts.box nat.nat) =>
              connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
          (b:(cts.Term cts.box nat.nat) =>
           _clearme0:(cts.Term
                        cts.star
                        (connectives.And (nat.le b n) (logic.eq nat.nat (g b) a))) =>
           connectives.match_And_prop
             (nat.le b n)
             (logic.eq nat.nat (g b) a)
             (connectives.ex
                nat.nat
                (p:(cts.Term cts.box nat.nat) =>
                 connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
             (lebn:(cts.Term cts.star (nat.le b n)) =>
              gb:(cts.Term cts.star (logic.eq nat.nat (g b) a)) =>
              connectives.ex_intro
                nat.nat
                (x:(cts.Term cts.box nat.nat) =>
                 connectives.And (nat.le x n) (logic.eq nat.nat (f (g x)) i))
                b
                (connectives.conj
                   (nat.le b n)
                   (logic.eq nat.nat (f (g b)) i)
                   lebn
                   (logic.rewrite_r
                      nat.nat
                      a
                      (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f __) i)
                      (logic.rewrite_r
                         nat.nat
                         i
                         (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat __ i)
                         (logic.refl nat.nat i)
                         (f a)
                         ga)
                      (g b)
                      gb)))
             _clearme0)
          (bijg a lean))
       _clearme)
    (bijf i lein).

def bijn_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x0 x)
                (x2:(cts.Term cts.star (nat.le x0 x)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x1 x)
                   (x3:(cts.Term cts.star (nat.le x1 x)) =>
                    permutation.bijn (permutation.transpose x0 x1) x))))))
  :=
  n:(cts.Term cts.box nat.nat) =>
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term cts.box nat.nat) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb a i) bool.true)
    (logic.eq bool.bool (nat.eqb a i) bool.false)
    (connectives.ex
       nat.nat
       (p:(cts.Term cts.box nat.nat) =>
        connectives.And (nat.le p n) (logic.eq nat.nat (permutation.transpose i j p) a)))
    (Hi:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a i) bool.true)) =>
     connectives.ex_intro
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        connectives.And (nat.le x n) (logic.eq nat.nat (permutation.transpose i j x) a))
       j
       (connectives.conj
          (nat.le j n)
          (logic.eq nat.nat (permutation.transpose i j j) a)
          lejn
          (logic.eq_ind_r
             nat.nat
             i
             (x:(cts.Term cts.box nat.nat) => logic.eq nat.nat x a)
             (logic.sym_eq nat.nat a i (nat.eqb_true_to_eq a i Hi))
             (permutation.transpose i j j)
             (permutation.transpose_i_j_j i j))))
    (Hi:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a i) bool.false)) =>
     connectives.match_Or_prop
       (logic.eq bool.bool (nat.eqb a j) bool.true)
       (logic.eq bool.bool (nat.eqb a j) bool.false)
       (connectives.ex
          nat.nat
          (p:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (permutation.transpose i j p) a)))
       (Hj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a j) bool.true)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le x n) (logic.eq nat.nat (permutation.transpose i j x) a))
          i
          (connectives.conj
             (nat.le i n)
             (logic.eq nat.nat (permutation.transpose i j i) a)
             lein
             (logic.eq_ind_r
                nat.nat
                j
                (x:(cts.Term cts.box nat.nat) => logic.eq nat.nat x a)
                (logic.sym_eq nat.nat a j (nat.eqb_true_to_eq a j Hj))
                (permutation.transpose i j i)
                (permutation.transpose_i_j_i i j))))
       (Hj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a j) bool.false)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le x n) (logic.eq nat.nat (permutation.transpose i j x) a))
          a
          (connectives.conj
             (nat.le a n)
             (logic.eq nat.nat (permutation.transpose i j a) a)
             lean
             (logic.eq_ind_r
                bool.bool
                bool.false
                (x:(cts.Term cts.box bool.bool) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i a (nat.eqb a j))
                      x)
                   a)
                (logic.eq_ind_r
                   bool.bool
                   bool.false
                   (x:(cts.Term cts.box bool.bool) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i a x)
                         bool.false)
                      a)
                   (bool.eq_match_bool_type_false
                      nat.nat
                      i
                      a
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i a bool.false)
                            bool.false)
                         y)
                      (bool.eq_match_bool_type_false
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i a bool.false)
                         (y:(cts.Term cts.box nat.nat) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type nat.nat i a bool.false)
                               bool.false)
                            y)
                         (logic.refl
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type nat.nat i a bool.false)
                               bool.false))))
                   (nat.eqb a j)
                   Hj)
                (nat.eqb a i)
                Hi)))
       (bool.true_or_false (nat.eqb a j)))
    (bool.true_or_false (nat.eqb a i)).

def permut_to_bijn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat))
          (x0:(cts.Term
                 cts.box
                 (cts.prod
                    cts.box
                    cts.box
                    cts.box
                    cts.I
                    nat.nat
                    (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x0 x)
             (x1:(cts.Term cts.star (permutation.permut x0 x)) => permutation.bijn x0 x))))
  :=
  n:(cts.Term cts.box nat.nat) =>
  nat.nat_ind
    (_x_365:(cts.Term cts.box nat.nat) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (permutation.permut x _x_365)
          (x0:(cts.Term cts.star (permutation.permut x _x_365)) => permutation.bijn x _x_365)))
    (f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     _clearme:(cts.Term
                 cts.star
                 (connectives.And
                    (cts.prod
                       cts.box
                       cts.star
                       cts.star
                       cts.I
                       nat.nat
                       (x:(cts.Term cts.box nat.nat) =>
                        cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (nat.le x nat.O)
                          (x0:(cts.Term cts.star (nat.le x nat.O)) => nat.le (f x) nat.O)))
                    (permutation.injn f nat.O))) =>
     connectives.match_And_prop
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x nat.O)
             (x0:(cts.Term cts.star (nat.le x nat.O)) => nat.le (f x) nat.O)))
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x nat.O)
                (x1:(cts.Term cts.star (nat.le x nat.O)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x0 nat.O)
                   (x2:(cts.Term cts.star (nat.le x0 nat.O)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat (f x) (f x0))
                      (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                       logic.eq nat.nat x x0))))))
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x nat.O)
             (x0:(cts.Term cts.star (nat.le x nat.O)) =>
              connectives.ex
                nat.nat
                (p:(cts.Term cts.box nat.nat) =>
                 connectives.And (nat.le p nat.O) (logic.eq nat.nat (f p) x)))))
       (H:(cts.Term
             cts.star
             (cts.prod'
                cts.box
                cts.star
                cts.star
                nat.nat
                (x:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x nat.O)
                   (x0:(cts.Term cts.star (nat.le x nat.O)) => nat.le (f x) nat.O)))) =>
        H1:(cts.Term
              cts.star
              (cts.prod'
                 cts.box
                 cts.star
                 cts.star
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.box
                    cts.star
                    cts.star
                    cts.I
                    nat.nat
                    (x0:(cts.Term cts.box nat.nat) =>
                     cts.prod
                       cts.star
                       cts.star
                       cts.star
                       cts.I
                       (nat.le x nat.O)
                       (x1:(cts.Term cts.star (nat.le x nat.O)) =>
                        cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (nat.le x0 nat.O)
                          (x2:(cts.Term cts.star (nat.le x0 nat.O)) =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (logic.eq nat.nat (f x) (f x0))
                             (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                              logic.eq nat.nat x x0))))))) =>
        m:(cts.Term cts.box nat.nat) =>
        lem0:(cts.Term cts.star (nat.le m nat.O)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           connectives.And (nat.le x nat.O) (logic.eq nat.nat (f x) m))
          nat.O
          (connectives.conj
             (nat.le nat.O nat.O)
             (logic.eq nat.nat (f nat.O) m)
             (nat.le_O_n nat.O)
             (nat.le_n_O_elim
                m
                lem0
                (logic.eq nat.nat (f nat.O))
                (logic.sym_eq
                   nat.nat
                   nat.O
                   (f nat.O)
                   (nat.le_n_O_to_eq (f nat.O) (H nat.O (nat.le_O_n nat.O)))))))
       _clearme)
    (m:(cts.Term cts.box nat.nat) =>
     Hind:(cts.Term
             cts.star
             (cts.prod'
                cts.box
                cts.star
                cts.star
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))
                (x:(cts.Term
                      cts.box
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.permut x m)
                   (x0:(cts.Term cts.star (permutation.permut x m)) => permutation.bijn x m)))) =>
     f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     permf:(cts.Term
              cts.star
              (connectives.And
                 (cts.prod
                    cts.box
                    cts.star
                    cts.star
                    cts.I
                    nat.nat
                    (x:(cts.Term cts.box nat.nat) =>
                     cts.prod
                       cts.star
                       cts.star
                       cts.star
                       cts.I
                       (nat.le x (nat.S m))
                       (x0:(cts.Term cts.star (nat.le x (nat.S m))) => nat.le (f x) (nat.S m))))
                 (permutation.injn f (nat.S m)))) =>
     permutation.eq_to_bijn
       (p:(cts.Term cts.box nat.nat) =>
        permutation.transpose
          (f (nat.S m))
          (nat.S m)
          (permutation.transpose (f (nat.S m)) (nat.S m) (f p)))
       f
       (nat.S m)
       (i:(cts.Term cts.box nat.nat) =>
        lei:(cts.Term cts.star (nat.le i (nat.S m))) =>
        permutation.transpose_transpose (f (nat.S m)) (nat.S m) (f i))
       (permutation.bijn_fg
          (permutation.transpose (f (nat.S m)) (nat.S m))
          (__:(cts.Term cts.box nat.nat) => permutation.transpose (f (nat.S m)) (nat.S m) (f __))
          (nat.S m)
          (connectives.match_And_prop
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x (nat.S m))
                   (x0:(cts.Term cts.star (nat.le x (nat.S m))) => nat.le (f x) (nat.S m))))
             (permutation.injn f (nat.S m))
             (permutation.bijn (permutation.transpose (f (nat.S m)) (nat.S m)) (nat.S m))
             (lef:(cts.Term
                     cts.star
                     (cts.prod'
                        cts.box
                        cts.star
                        cts.star
                        nat.nat
                        (x:(cts.Term cts.box nat.nat) =>
                         cts.prod
                           cts.star
                           cts.star
                           cts.star
                           cts.I
                           (nat.le x (nat.S m))
                           (x0:(cts.Term cts.star (nat.le x (nat.S m))) =>
                            nat.le (f x) (nat.S m))))) =>
              __:(cts.Term
                    cts.star
                    (cts.prod'
                       cts.box
                       cts.star
                       cts.star
                       nat.nat
                       (x:(cts.Term cts.box nat.nat) =>
                        cts.prod
                          cts.box
                          cts.star
                          cts.star
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x (nat.S m))
                             (x1:(cts.Term cts.star (nat.le x (nat.S m))) =>
                              cts.prod
                                cts.star
                                cts.star
                                cts.star
                                cts.I
                                (nat.le x0 (nat.S m))
                                (x2:(cts.Term cts.star (nat.le x0 (nat.S m))) =>
                                 cts.prod
                                   cts.star
                                   cts.star
                                   cts.star
                                   cts.I
                                   (logic.eq nat.nat (f x) (f x0))
                                   (x3:(cts.Term
                                          cts.star
                                          (logic.eq nat.nat (f x) (f x0))) =>
                                    logic.eq nat.nat x x0))))))) =>
              permutation.bijn_transpose
                (nat.S m)
                (f (nat.S m))
                (nat.S m)
                (lef (nat.S m) (nat.le_n (nat.S m)))
                (nat.le_n (nat.S m)))
             permf)
          (permutation.bijn_n_Sn
             (__:(cts.Term cts.box nat.nat) =>
              permutation.transpose (f (nat.S m)) (nat.S m) (f __))
             m
             (Hind
                (__:(cts.Term cts.box nat.nat) =>
                 permutation.transpose (f (nat.S m)) (nat.S m) (f __))
                (permutation.permut_S_to_permut_transpose f m permf))
             (logic.eq_ind_r
                bool.bool
                bool.true
                (x:(cts.Term cts.box bool.bool) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      (nat.S m)
                      (bool.match_bool_type
                         nat.nat
                         (f (nat.S m))
                         (f (nat.S m))
                         (nat.eqb (f (nat.S m)) (nat.S m)))
                      x)
                   (nat.S m))
                (bool.eq_match_bool_type_true
                   nat.nat
                   (nat.S m)
                   (bool.match_bool_type
                      nat.nat
                      (f (nat.S m))
                      (f (nat.S m))
                      (nat.eqb (f (nat.S m)) (nat.S m)))
                   (y:(cts.Term cts.box nat.nat) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         (nat.S m)
                         (bool.match_bool_type
                            nat.nat
                            (f (nat.S m))
                            (f (nat.S m))
                            (nat.eqb (f (nat.S m)) (nat.S m)))
                         bool.true)
                      y)
                   (logic.refl
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         (nat.S m)
                         (bool.match_bool_type
                            nat.nat
                            (f (nat.S m))
                            (f (nat.S m))
                            (nat.eqb (f (nat.S m)) (nat.S m)))
                         bool.true)))
                (nat.eqb (f (nat.S m)) (f (nat.S m)))
                (nat.eqb_n_n (f (nat.S m)))))))
    n.

invert_permut :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat))))).

invert_permut_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat))))).

axiom_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (permutation.invert_permut x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))
                (x0:(cts.Term
                       cts.box
                       (cts.prod
                          cts.box
                          cts.box
                          cts.box
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x1:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             x))).

def eq_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (permutation.invert_permut x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))
                (x0:(cts.Term
                       cts.box
                       (cts.prod
                          cts.box
                          cts.box
                          cts.box
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x1:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             x)))
  :=
  n:(cts.Term cts.box nat.nat) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut n)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat)))
       permutation.invert_permut_body
       n)
    (permutation.axiom_invert_permut n).

def sym_eq_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))
                (x0:(cts.Term
                       cts.box
                       (cts.prod
                          cts.box
                          cts.box
                          cts.box
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x1:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             x)
          (permutation.invert_permut x)))
  :=
  n:(cts.Term cts.box nat.nat) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut n)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat)))
       permutation.invert_permut_body
       n)
    (permutation.eq_invert_permut n).

axiom_invert_permut_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat)))
       (permutation.invert_permut_body nat.O)
       (f:(cts.Term
             cts.box
             (cts.prod'
                cts.box
                cts.box
                cts.box
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        m:(cts.Term cts.box nat.nat) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))).

def eq_invert_permut_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat)))
       (permutation.invert_permut_body nat.O)
       (f:(cts.Term
             cts.box
             (cts.prod'
                cts.box
                cts.box
                cts.box
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        m:(cts.Term cts.box nat.nat) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O))))
  :=
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut_body nat.O)
    (f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     m:(cts.Term cts.box nat.nat) => bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
    permutation.axiom_invert_permut_body_O.

def sym_eq_invert_permut_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
          (x:(cts.Term
                cts.box
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0:(cts.Term cts.box nat.nat) => nat.nat)))
       (f:(cts.Term
             cts.box
             (cts.prod'
                cts.box
                cts.box
                cts.box
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        m:(cts.Term cts.box nat.nat) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
       (permutation.invert_permut_body nat.O))
  :=
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut_body nat.O)
    (f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     m:(cts.Term cts.box nat.nat) => bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
    permutation.eq_invert_permut_body_O.

axiom_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (permutation.invert_permut_body (nat.S x))
          (f:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           m:(cts.Term cts.box nat.nat) =>
           bool.match_bool_type
             nat.nat
             (nat.S x)
             (permutation.invert_permut x f m)
             (nat.eqb m (f (nat.S x)))))).

def eq_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (permutation.invert_permut_body (nat.S x))
          (f:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           m:(cts.Term cts.box nat.nat) =>
           bool.match_bool_type
             nat.nat
             (nat.S x)
             (permutation.invert_permut x f m)
             (nat.eqb m (f (nat.S x))))))
  :=
  n:(cts.Term cts.box nat.nat) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut_body (nat.S n))
    (f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     m:(cts.Term cts.box nat.nat) =>
     bool.match_bool_type
       nat.nat
       (nat.S n)
       (permutation.invert_permut n f m)
       (nat.eqb m (f (nat.S n))))
    (permutation.axiom_invert_permut_body_S n).

def sym_eq_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat))
             (x0:(cts.Term
                    cts.box
                    (cts.prod
                       cts.box
                       cts.box
                       cts.box
                       cts.I
                       nat.nat
                       (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x1:(cts.Term cts.box nat.nat) => nat.nat)))
          (f:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
           m:(cts.Term cts.box nat.nat) =>
           bool.match_bool_type
             nat.nat
             (nat.S x)
             (permutation.invert_permut x f m)
             (nat.eqb m (f (nat.S x))))
          (permutation.invert_permut_body (nat.S x))))
  :=
  n:(cts.Term cts.box nat.nat) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod cts.box cts.box cts.box cts.I nat.nat (x0:(cts.Term cts.box nat.nat) => nat.nat)))
    (permutation.invert_permut_body (nat.S n))
    (f:(cts.Term
          cts.box
          (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
     m:(cts.Term cts.box nat.nat) =>
     bool.match_bool_type
       nat.nat
       (nat.S n)
       (permutation.invert_permut n f m)
       (nat.eqb m (f (nat.S n))))
    (permutation.eq_invert_permut_body_S n).

def invert_permut_f :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x1 x0)
                (x2:(cts.Term cts.star (nat.le x1 x0)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.injn x x0)
                   (x3:(cts.Term cts.star (permutation.injn x x0)) =>
                    logic.eq nat.nat (permutation.invert_permut x0 x (x x1)) x1))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  m:(cts.Term cts.box nat.nat) =>
  lenm:(cts.Term cts.star (nat.le m n)) =>
  nat.le_ind
    m
    (x_417:(cts.Term cts.box nat.nat) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (permutation.injn f x_417)
       (x:(cts.Term cts.star (permutation.injn f x_417)) =>
        logic.eq nat.nat (permutation.invert_permut x_417 f (f m)) m))
    (nat.match_nat_prop
       (__:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (permutation.injn f __)
          (x:(cts.Term cts.star (permutation.injn f __)) =>
           logic.eq nat.nat (permutation.invert_permut __ f (f __)) __))
       (permutation.sym_eq_invert_permut
          nat.O
          (y:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) => nat.nat))
                   (x0:(cts.Term
                          cts.box
                          (cts.prod
                             cts.box
                             cts.box
                             cts.box
                             cts.I
                             nat.nat
                             (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                    cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.injn f nat.O)
             (x:(cts.Term cts.star (permutation.injn f nat.O)) =>
              logic.eq nat.nat (y f (f nat.O)) nat.O))
          (nat.sym_eq_filter_nat_type_O
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))
                (x:(cts.Term
                      cts.box
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             (y:(cts.Term
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))
                      (x:(cts.Term
                            cts.box
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                       cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (permutation.injn f nat.O)
                (x:(cts.Term cts.star (permutation.injn f nat.O)) =>
                 logic.eq nat.nat (y f (f nat.O)) nat.O))
             (permutation.sym_eq_invert_permut_body_O
                (y:(cts.Term
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         (cts.prod'
                            cts.box
                            cts.box
                            cts.box
                            nat.nat
                            (x:(cts.Term cts.box nat.nat) => nat.nat))
                         (x:(cts.Term
                               cts.box
                               (cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                          cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.injn f nat.O)
                   (x:(cts.Term cts.star (permutation.injn f nat.O)) =>
                    logic.eq nat.nat (y f (f nat.O)) nat.O))
                (logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term cts.box bool.bool) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x1:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (nat.le x0 nat.O)
                               (x2:(cts.Term cts.star (nat.le x0 nat.O)) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x1 nat.O)
                                  (x3:(cts.Term cts.star (nat.le x1 nat.O)) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (f x0) (f x1))
                                     (x4:(cts.Term
                                            cts.star
                                            (logic.eq nat.nat (f x0) (f x1))) =>
                                      logic.eq nat.nat x0 x1))))))
                      (x0:(cts.Term
                             cts.star
                             (cts.prod
                                cts.box
                                cts.star
                                cts.star
                                cts.I
                                nat.nat
                                (x0:(cts.Term cts.box nat.nat) =>
                                 cts.prod
                                   cts.box
                                   cts.star
                                   cts.star
                                   cts.I
                                   nat.nat
                                   (x1:(cts.Term cts.box nat.nat) =>
                                    cts.prod
                                      cts.star
                                      cts.star
                                      cts.star
                                      cts.I
                                      (nat.le x0 nat.O)
                                      (x2:(cts.Term cts.star (nat.le x0 nat.O)) =>
                                       cts.prod
                                         cts.star
                                         cts.star
                                         cts.star
                                         cts.I
                                         (nat.le x1 nat.O)
                                         (x3:(cts.Term cts.star (nat.le x1 nat.O)) =>
                                          cts.prod
                                            cts.star
                                            cts.star
                                            cts.star
                                            cts.I
                                            (logic.eq nat.nat (f x0) (f x1))
                                            (x4:(cts.Term
                                                   cts.star
                                                   (logic.eq nat.nat (f x0) (f x1))) =>
                                             logic.eq nat.nat x0 x1))))))) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat nat.O nat.O x) nat.O))
                   (auto:(cts.Term
                            cts.star
                            (cts.prod'
                               cts.box
                               cts.star
                               cts.star
                               nat.nat
                               (x0:(cts.Term cts.box nat.nat) =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x1:(cts.Term cts.box nat.nat) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (nat.le x0 nat.O)
                                     (x2:(cts.Term cts.star (nat.le x0 nat.O)) =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (nat.le x1 nat.O)
                                        (x3:(cts.Term cts.star (nat.le x1 nat.O)) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (logic.eq nat.nat (f x0) (f x1))
                                           (x4:(cts.Term
                                                  cts.star
                                                  (logic.eq nat.nat (f x0) (f x1))) =>
                                            logic.eq nat.nat x0 x1))))))) =>
                    bool.eq_match_bool_type_true
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat nat.O nat.O bool.true) y)
                      (logic.refl nat.nat (bool.match_bool_type nat.nat nat.O nat.O bool.true)))
                   (nat.eqb (f nat.O) (f nat.O))
                   (nat.eqb_n_n (f nat.O))))))
       (a:(cts.Term cts.box nat.nat) =>
        permutation.sym_eq_invert_permut
          (nat.S a)
          (y:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) => nat.nat))
                   (x0:(cts.Term
                          cts.box
                          (cts.prod
                             cts.box
                             cts.box
                             cts.box
                             cts.I
                             nat.nat
                             (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                    cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.injn f (nat.S a))
             (x:(cts.Term cts.star (permutation.injn f (nat.S a))) =>
              logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
          (nat.sym_eq_filter_nat_type_S
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))
                (x:(cts.Term
                      cts.box
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             a
             (y:(cts.Term
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))
                      (x:(cts.Term
                            cts.box
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                       cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (permutation.injn f (nat.S a))
                (x:(cts.Term cts.star (permutation.injn f (nat.S a))) =>
                 logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
             (permutation.sym_eq_invert_permut_body_S
                a
                (y:(cts.Term
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         (cts.prod'
                            cts.box
                            cts.box
                            cts.box
                            nat.nat
                            (x0:(cts.Term cts.box nat.nat) => nat.nat))
                         (x0:(cts.Term
                                cts.box
                                (cts.prod
                                   cts.box
                                   cts.box
                                   cts.box
                                   cts.I
                                   nat.nat
                                   (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                          cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.injn f (nat.S a))
                   (x:(cts.Term cts.star (permutation.injn f (nat.S a))) =>
                    logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
                (logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term cts.box bool.bool) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x1:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (nat.le x0 (nat.S a))
                               (x2:(cts.Term cts.star (nat.le x0 (nat.S a))) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x1 (nat.S a))
                                  (x3:(cts.Term cts.star (nat.le x1 (nat.S a))) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (f x0) (f x1))
                                     (x4:(cts.Term
                                            cts.star
                                            (logic.eq nat.nat (f x0) (f x1))) =>
                                      logic.eq nat.nat x0 x1))))))
                      (x0:(cts.Term
                             cts.star
                             (cts.prod
                                cts.box
                                cts.star
                                cts.star
                                cts.I
                                nat.nat
                                (x0:(cts.Term cts.box nat.nat) =>
                                 cts.prod
                                   cts.box
                                   cts.star
                                   cts.star
                                   cts.I
                                   nat.nat
                                   (x1:(cts.Term cts.box nat.nat) =>
                                    cts.prod
                                      cts.star
                                      cts.star
                                      cts.star
                                      cts.I
                                      (nat.le x0 (nat.S a))
                                      (x2:(cts.Term cts.star (nat.le x0 (nat.S a))) =>
                                       cts.prod
                                         cts.star
                                         cts.star
                                         cts.star
                                         cts.I
                                         (nat.le x1 (nat.S a))
                                         (x3:(cts.Term
                                                cts.star
                                                (nat.le x1 (nat.S a))) =>
                                          cts.prod
                                            cts.star
                                            cts.star
                                            cts.star
                                            cts.I
                                            (logic.eq nat.nat (f x0) (f x1))
                                            (x4:(cts.Term
                                                   cts.star
                                                   (logic.eq nat.nat (f x0) (f x1))) =>
                                             logic.eq nat.nat x0 x1))))))) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (permutation.invert_permut a f (f (nat.S a)))
                            x)
                         (nat.S a)))
                   (auto:(cts.Term
                            cts.star
                            (cts.prod'
                               cts.box
                               cts.star
                               cts.star
                               nat.nat
                               (x0:(cts.Term cts.box nat.nat) =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x1:(cts.Term cts.box nat.nat) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (nat.le x0 (nat.S a))
                                     (x2:(cts.Term cts.star (nat.le x0 (nat.S a))) =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (nat.le x1 (nat.S a))
                                        (x3:(cts.Term cts.star (nat.le x1 (nat.S a))) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (logic.eq nat.nat (f x0) (f x1))
                                           (x4:(cts.Term
                                                  cts.star
                                                  (logic.eq nat.nat (f x0) (f x1))) =>
                                            logic.eq nat.nat x0 x1))))))) =>
                    bool.eq_match_bool_type_true
                      nat.nat
                      (nat.S a)
                      (permutation.invert_permut a f (f (nat.S a)))
                      (y:(cts.Term cts.box nat.nat) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (permutation.invert_permut a f (f (nat.S a)))
                            bool.true)
                         y)
                      (logic.refl
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (permutation.invert_permut a f (f (nat.S a)))
                            bool.true)))
                   (nat.eqb (f (nat.S a)) (f (nat.S a)))
                   (nat.eqb_n_n (f (nat.S a)))))))
       m)
    (m0:(cts.Term cts.box nat.nat) =>
     permutation.sym_eq_invert_permut
       (nat.S m0)
       (y:(cts.Term
             cts.box
             (cts.prod'
                cts.box
                cts.box
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat))
                (x0:(cts.Term
                       cts.box
                       (cts.prod
                          cts.box
                          cts.box
                          cts.box
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le m m0)
          (x:(cts.Term cts.star (nat.le m m0)) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (permutation.injn f m0)
                (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                 logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))
             (x0:(cts.Term
                    cts.star
                    (cts.prod
                       cts.star
                       cts.star
                       cts.star
                       cts.I
                       (permutation.injn f m0)
                       (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                        logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (permutation.injn f (nat.S m0))
                (x1:(cts.Term cts.star (permutation.injn f (nat.S m0))) =>
                 logic.eq nat.nat (y f (f m)) m))))
       (nat.sym_eq_filter_nat_type_S
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))
             (x:(cts.Term
                   cts.box
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) => nat.nat)))
          permutation.invert_permut_body
          m0
          (y:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      nat.nat
                      (x:(cts.Term cts.box nat.nat) => nat.nat))
                   (x:(cts.Term
                         cts.box
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                    cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le m m0)
             (x:(cts.Term cts.star (nat.le m m0)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.injn f m0)
                   (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                    logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))
                (x0:(cts.Term
                       cts.star
                       (cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (permutation.injn f m0)
                          (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                           logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.injn f (nat.S m0))
                   (x1:(cts.Term cts.star (permutation.injn f (nat.S m0))) =>
                    logic.eq nat.nat (y f (f m)) m))))
          (permutation.sym_eq_invert_permut_body_S
             m0
             (y:(cts.Term
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) => nat.nat))
                      (x0:(cts.Term
                             cts.box
                             (cts.prod
                                cts.box
                                cts.box
                                cts.box
                                cts.I
                                nat.nat
                                (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                       cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le m m0)
                (x:(cts.Term cts.star (nat.le m m0)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (permutation.injn f m0)
                      (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                       logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))
                   (x0:(cts.Term
                          cts.star
                          (cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (permutation.injn f m0)
                             (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                              logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (permutation.injn f (nat.S m0))
                      (x1:(cts.Term cts.star (permutation.injn f (nat.S m0))) =>
                       logic.eq nat.nat (y f (f m)) m))))
             (lem:(cts.Term cts.star (nat.le m m0)) =>
              H:(cts.Term
                   cts.star
                   (cts.prod'
                      cts.star
                      cts.star
                      cts.star
                      (cts.prod'
                         cts.box
                         cts.star
                         cts.star
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x0:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (nat.le x m0)
                               (x1:(cts.Term cts.star (nat.le x m0)) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x0 m0)
                                  (x2:(cts.Term cts.star (nat.le x0 m0)) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (f x) (f x0))
                                     (x3:(cts.Term
                                            cts.star
                                            (logic.eq nat.nat (f x) (f x0))) =>
                                      logic.eq nat.nat x x0))))))
                      (x0:(cts.Term cts.star (permutation.injn f m0)) =>
                       logic.eq nat.nat (permutation.invert_permut m0 f (f m)) m))) =>
              H1:(cts.Term
                    cts.star
                    (cts.prod'
                       cts.box
                       cts.star
                       cts.star
                       nat.nat
                       (x:(cts.Term cts.box nat.nat) =>
                        cts.prod
                          cts.box
                          cts.star
                          cts.star
                          cts.I
                          nat.nat
                          (x0:(cts.Term cts.box nat.nat) =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x (nat.S m0))
                             (x1:(cts.Term cts.star (nat.le x (nat.S m0))) =>
                              cts.prod
                                cts.star
                                cts.star
                                cts.star
                                cts.I
                                (nat.le x0 (nat.S m0))
                                (x2:(cts.Term cts.star (nat.le x0 (nat.S m0))) =>
                                 cts.prod
                                   cts.star
                                   cts.star
                                   cts.star
                                   cts.I
                                   (logic.eq nat.nat (f x) (f x0))
                                   (x3:(cts.Term
                                          cts.star
                                          (logic.eq nat.nat (f x) (f x0))) =>
                                    logic.eq nat.nat x x0))))))) =>
              logic.eq_ind_r
                bool.bool
                bool.false
                (x:(cts.Term cts.box bool.bool) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      (nat.S m0)
                      (permutation.invert_permut m0 f (f m))
                      x)
                   m)
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   (nat.S m0)
                   (permutation.invert_permut m0 f (f m))
                   (y:(cts.Term cts.box nat.nat) => logic.eq nat.nat y m)
                   (H (permutation.injn_Sn_n f m0 H1)))
                (nat.eqb (f m) (f (nat.S m0)))
                (nat.not_eq_to_eqb_false
                   (f m)
                   (f (nat.S m0))
                   (connectives.nmk
                      (logic.eq nat.nat (f m) (f (nat.S m0)))
                      (eqf:(cts.Term cts.star (logic.eq nat.nat (f m) (f (nat.S m0)))) =>
                       logic.absurd
                         (logic.eq nat.nat m (nat.S m0))
                         (H1
                            m
                            (nat.S m0)
                            (nat.le_S m m0 lem)
                            (nat.le_n (nat.S m0))
                            (logic.rewrite_l
                               nat.nat
                               (f m)
                               (__:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f m) __)
                               (logic.refl nat.nat (f m))
                               (f (nat.S m0))
                               eqf))
                         (nat.lt_to_not_eq m (nat.S m0) (nat.le_S_S m m0 lem)))))))))
    n
    lenm.

def let_clause_1063 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x x0)
             (x1:(cts.Term cts.star (permutation.permut x x0)) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x0)
                      (x4:(cts.Term cts.star (nat.le x2 x0)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x0)
                         (x5:(cts.Term cts.star (nat.le x3 x0)) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x6:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.And (nat.le x6 x0) (logic.eq nat.nat (x x6) x2))
                               (x7:(cts.Term
                                      cts.star
                                      (connectives.And
                                         (nat.le x6 x0)
                                         (logic.eq nat.nat (x x6) x2))) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x6 x0)
                                  (x8:(cts.Term cts.star (nat.le x6 x0)) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (x x6) x2)
                                     (x9:(cts.Term
                                            cts.star
                                            (logic.eq nat.nat (x x6) x2)) =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10:(cts.Term cts.box nat.nat) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.And
                                              (nat.le x10 x0)
                                              (logic.eq nat.nat (x x10) x3))
                                           (x11:(cts.Term
                                                   cts.star
                                                   (connectives.And
                                                      (nat.le x10 x0)
                                                      (logic.eq nat.nat (x x10) x3))) =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (nat.le x10 x0)
                                              (x12:(cts.Term
                                                      cts.star
                                                      (nat.le x10 x0)) =>
                                               cts.prod
                                                 cts.star
                                                 cts.star
                                                 cts.star
                                                 cts.I
                                                 (logic.eq nat.nat (x x10) x3)
                                                 (x13:(cts.Term
                                                         cts.star
                                                         (logic.eq
                                                            nat.nat
                                                            (x x10)
                                                            x3)) =>
                                                  cts.prod
                                                    cts.star
                                                    cts.star
                                                    cts.star
                                                    cts.I
                                                    (cts.prod
                                                       cts.box
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       nat.nat
                                                       (x14:(cts.Term
                                                               cts.box
                                                               nat.nat) =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (nat.le x14 x0)
                                                          (x15:(cts.Term
                                                                  cts.star
                                                                  (nat.le
                                                                    x14
                                                                    x0)) =>
                                                           nat.le (x x14) x0)))
                                                    (x14:(cts.Term
                                                            cts.star
                                                            (cts.prod
                                                               cts.box
                                                               cts.star
                                                               cts.star
                                                               cts.I
                                                               nat.nat
                                                               (x14:(
                                                                cts.Term
                                                                  cts.box
                                                                  nat.nat) =>
                                                                cts.prod
                                                                  cts.star
                                                                  cts.star
                                                                  cts.star
                                                                  cts.I
                                                                  (nat.le
                                                                    x14
                                                                    x0)
                                                                  (x15:(
                                                                   cts.Term
                                                                    cts.star
                                                                    (nat.le
                                                                    x14
                                                                    x0)) =>
                                                                   nat.le
                                                                    (x x14)
                                                                    x0)))) =>
                                                     cts.prod
                                                       cts.star
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       (permutation.injn x x0)
                                                       (x15:(cts.Term
                                                               cts.star
                                                               (permutation.injn
                                                                  x
                                                                  x0)) =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (logic.eq nat.nat x6 x10)
                                                          (x16:(cts.Term
                                                                  cts.star
                                                                  (logic.eq
                                                                    nat.nat
                                                                    x6
                                                                    x10)) =>
                                                           logic.eq
                                                             nat.nat
                                                             (x x6)
                                                             x3)))))))))))))))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  permf:(cts.Term
           cts.star
           (connectives.And
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (nat.le x n)
                    (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
              (permutation.injn f n))) =>
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term cts.box nat.nat) =>
  _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
  b:(cts.Term cts.box nat.nat) =>
  _clearme0:(cts.Term cts.star (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
  lebn:(cts.Term cts.star (nat.le b n)) =>
  fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
  __:(cts.Term
        cts.star
        (cts.prod'
           cts.box
           cts.star
           cts.star
           nat.nat
           (x14:(cts.Term cts.box nat.nat) =>
            cts.prod
              cts.star
              cts.star
              cts.star
              cts.I
              (nat.le x14 n)
              (x15:(cts.Term cts.star (nat.le x14 n)) => nat.le (f x14) n)))) =>
  injf:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x n)
                   (x1:(cts.Term cts.star (nat.le x n)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x0 n)
                      (x2:(cts.Term cts.star (nat.le x0 n)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat.nat (f x) (f x0))
                         (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                          logic.eq nat.nat x x0))))))) =>
  auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
  logic.rewrite_r nat.nat b (__1:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f __1) j) fb a auto.

def let_clause_1068 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x x0)
             (x1:(cts.Term cts.star (permutation.permut x x0)) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x0)
                      (x4:(cts.Term cts.star (nat.le x2 x0)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x0)
                         (x5:(cts.Term cts.star (nat.le x3 x0)) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x6:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.And (nat.le x6 x0) (logic.eq nat.nat (x x6) x2))
                               (x7:(cts.Term
                                      cts.star
                                      (connectives.And
                                         (nat.le x6 x0)
                                         (logic.eq nat.nat (x x6) x2))) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x6 x0)
                                  (x8:(cts.Term cts.star (nat.le x6 x0)) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (x x6) x2)
                                     (x9:(cts.Term
                                            cts.star
                                            (logic.eq nat.nat (x x6) x2)) =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10:(cts.Term cts.box nat.nat) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.And
                                              (nat.le x10 x0)
                                              (logic.eq nat.nat (x x10) x3))
                                           (x11:(cts.Term
                                                   cts.star
                                                   (connectives.And
                                                      (nat.le x10 x0)
                                                      (logic.eq nat.nat (x x10) x3))) =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (nat.le x10 x0)
                                              (x12:(cts.Term
                                                      cts.star
                                                      (nat.le x10 x0)) =>
                                               cts.prod
                                                 cts.star
                                                 cts.star
                                                 cts.star
                                                 cts.I
                                                 (logic.eq nat.nat (x x10) x3)
                                                 (x13:(cts.Term
                                                         cts.star
                                                         (logic.eq
                                                            nat.nat
                                                            (x x10)
                                                            x3)) =>
                                                  cts.prod
                                                    cts.star
                                                    cts.star
                                                    cts.star
                                                    cts.I
                                                    (cts.prod
                                                       cts.box
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       nat.nat
                                                       (x14:(cts.Term
                                                               cts.box
                                                               nat.nat) =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (nat.le x14 x0)
                                                          (x15:(cts.Term
                                                                  cts.star
                                                                  (nat.le
                                                                    x14
                                                                    x0)) =>
                                                           nat.le (x x14) x0)))
                                                    (x14:(cts.Term
                                                            cts.star
                                                            (cts.prod
                                                               cts.box
                                                               cts.star
                                                               cts.star
                                                               cts.I
                                                               nat.nat
                                                               (x14:(
                                                                cts.Term
                                                                  cts.box
                                                                  nat.nat) =>
                                                                cts.prod
                                                                  cts.star
                                                                  cts.star
                                                                  cts.star
                                                                  cts.I
                                                                  (nat.le
                                                                    x14
                                                                    x0)
                                                                  (x15:(
                                                                   cts.Term
                                                                    cts.star
                                                                    (nat.le
                                                                    x14
                                                                    x0)) =>
                                                                   nat.le
                                                                    (x x14)
                                                                    x0)))) =>
                                                     cts.prod
                                                       cts.star
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       (permutation.injn x x0)
                                                       (x15:(cts.Term
                                                               cts.star
                                                               (permutation.injn
                                                                  x
                                                                  x0)) =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (logic.eq nat.nat x6 x10)
                                                          (x16:(cts.Term
                                                                  cts.star
                                                                  (logic.eq
                                                                    nat.nat
                                                                    x6
                                                                    x10)) =>
                                                           logic.eq
                                                             nat.nat
                                                             (x x6)
                                                             x2)))))))))))))))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  permf:(cts.Term
           cts.star
           (connectives.And
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (nat.le x n)
                    (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
              (permutation.injn f n))) =>
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term cts.box nat.nat) =>
  _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
  b:(cts.Term cts.box nat.nat) =>
  _clearme0:(cts.Term cts.star (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
  lebn:(cts.Term cts.star (nat.le b n)) =>
  fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
  __:(cts.Term
        cts.star
        (cts.prod'
           cts.box
           cts.star
           cts.star
           nat.nat
           (x14:(cts.Term cts.box nat.nat) =>
            cts.prod
              cts.star
              cts.star
              cts.star
              cts.I
              (nat.le x14 n)
              (x15:(cts.Term cts.star (nat.le x14 n)) => nat.le (f x14) n)))) =>
  injf:(cts.Term
          cts.star
          (cts.prod'
             cts.box
             cts.star
             cts.star
             nat.nat
             (x:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x0:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x n)
                   (x1:(cts.Term cts.star (nat.le x n)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x0 n)
                      (x2:(cts.Term cts.star (nat.le x0 n)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat.nat (f x) (f x0))
                         (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                          logic.eq nat.nat x x0))))))) =>
  auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
  logic.rewrite_l
    nat.nat
    j
    (__1:(cts.Term cts.box nat.nat) => logic.eq nat.nat (f a) __1)
    (permutation.let_clause_1063
       f
       n
       permf
       i
       j
       lein
       lejn
       a
       _clearme
       lean
       fa
       b
       _clearme0
       lebn
       fb
       __
       injf
       auto)
    i
    (logic.rewrite_l
       nat.nat
       (f a)
       (__1:(cts.Term cts.box nat.nat) => logic.eq nat.nat __1 i)
       fa
       j
       (permutation.let_clause_1063
          f
          n
          permf
          i
          j
          lein
          lejn
          a
          _clearme
          lean
          fa
          b
          _clearme0
          lebn
          fb
          __
          injf
          auto)).

def injective_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x x0)
             (x1:(cts.Term cts.star (permutation.permut x x0)) =>
              permutation.injn (permutation.invert_permut x0 x) x0))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  permf:(cts.Term
           cts.star
           (connectives.And
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (nat.le x n)
                    (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
              (permutation.injn f n))) =>
  i:(cts.Term cts.box nat.nat) =>
  j:(cts.Term cts.box nat.nat) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (logic.eq nat.nat (permutation.invert_permut n f i) (permutation.invert_permut n f j))
       (x:(cts.Term
             cts.star
             (logic.eq
                nat.nat
                (permutation.invert_permut n f i)
                (permutation.invert_permut n f j))) =>
        logic.eq nat.nat i j))
    (a:(cts.Term cts.box nat.nat) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (logic.eq nat.nat (permutation.invert_permut n f i) (permutation.invert_permut n f j))
          (x:(cts.Term
                cts.star
                (logic.eq
                   nat.nat
                   (permutation.invert_permut n f i)
                   (permutation.invert_permut n f j))) =>
           logic.eq nat.nat i j))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.match_ex_prop
          nat.nat
          (p:(cts.Term cts.box nat.nat) => connectives.And (nat.le p n) (logic.eq nat.nat (f p) j))
          (cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat (permutation.invert_permut n f i) (permutation.invert_permut n f j))
             (x:(cts.Term
                   cts.star
                   (logic.eq
                      nat.nat
                      (permutation.invert_permut n f i)
                      (permutation.invert_permut n f j))) =>
              logic.eq nat.nat i j))
          (b:(cts.Term cts.box nat.nat) =>
           _clearme0:(cts.Term
                        cts.star
                        (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
           connectives.match_And_prop
             (nat.le b n)
             (logic.eq nat.nat (f b) j)
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq
                   nat.nat
                   (permutation.invert_permut n f i)
                   (permutation.invert_permut n f j))
                (x:(cts.Term
                      cts.star
                      (logic.eq
                         nat.nat
                         (permutation.invert_permut n f i)
                         (permutation.invert_permut n f j))) =>
                 logic.eq nat.nat i j))
             (lebn:(cts.Term cts.star (nat.le b n)) =>
              fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
              connectives.match_And_prop
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x n)
                      (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
                (permutation.injn f n)
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq
                      nat.nat
                      (permutation.invert_permut n f i)
                      (permutation.invert_permut n f j))
                   (x:(cts.Term
                         cts.star
                         (logic.eq
                            nat.nat
                            (permutation.invert_permut n f i)
                            (permutation.invert_permut n f j))) =>
                    logic.eq nat.nat i j))
                (__:(cts.Term
                       cts.star
                       (cts.prod'
                          cts.box
                          cts.star
                          cts.star
                          nat.nat
                          (x:(cts.Term cts.box nat.nat) =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x n)
                             (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))) =>
                 injf:(cts.Term
                         cts.star
                         (cts.prod'
                            cts.box
                            cts.star
                            cts.star
                            nat.nat
                            (x:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat.nat
                               (x0:(cts.Term cts.box nat.nat) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x n)
                                  (x1:(cts.Term cts.star (nat.le x n)) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (nat.le x0 n)
                                     (x2:(cts.Term cts.star (nat.le x0 n)) =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (logic.eq nat.nat (f x) (f x0))
                                        (x3:(cts.Term
                                               cts.star
                                               (logic.eq nat.nat (f x) (f x0))) =>
                                         logic.eq nat.nat x x0))))))) =>
                 logic.eq_ind
                   nat.nat
                   (f a)
                   (x_1:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq
                         nat.nat
                         (permutation.invert_permut n f x_1)
                         (permutation.invert_permut n f j))
                      (x:(cts.Term
                            cts.star
                            (logic.eq
                               nat.nat
                               (permutation.invert_permut n f x_1)
                               (permutation.invert_permut n f j))) =>
                       logic.eq nat.nat x_1 j))
                   (logic.eq_ind
                      nat.nat
                      (f b)
                      (x_1:(cts.Term cts.box nat.nat) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq
                            nat.nat
                            (permutation.invert_permut n f (f a))
                            (permutation.invert_permut n f x_1))
                         (x:(cts.Term
                               cts.star
                               (logic.eq
                                  nat.nat
                                  (permutation.invert_permut n f (f a))
                                  (permutation.invert_permut n f x_1))) =>
                          logic.eq nat.nat (f a) x_1))
                      (logic.eq_ind_r
                         nat.nat
                         a
                         (x:(cts.Term cts.box nat.nat) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat.nat x (permutation.invert_permut n f (f b)))
                            (x0:(cts.Term
                                   cts.star
                                   (logic.eq
                                      nat.nat
                                      x
                                      (permutation.invert_permut n f (f b)))) =>
                             logic.eq nat.nat (f a) (f b)))
                         (logic.eq_ind_r
                            nat.nat
                            b
                            (x:(cts.Term cts.box nat.nat) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat.nat a x)
                               (x0:(cts.Term cts.star (logic.eq nat.nat a x)) =>
                                logic.eq nat.nat (f a) (f b)))
                            (auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
                             logic.rewrite_r
                               nat.nat
                               i
                               (__1:(cts.Term cts.box nat.nat) => logic.eq nat.nat __1 (f b))
                               (logic.rewrite_l
                                  nat.nat
                                  a
                                  (__1:(cts.Term cts.box nat.nat) =>
                                   logic.eq nat.nat i (f __1))
                                  (logic.rewrite_r
                                     nat.nat
                                     i
                                     (__1:(cts.Term cts.box nat.nat) =>
                                      logic.eq nat.nat i __1)
                                     (logic.refl nat.nat i)
                                     (f a)
                                     (permutation.let_clause_1068
                                        f
                                        n
                                        permf
                                        i
                                        j
                                        lein
                                        lejn
                                        a
                                        _clearme
                                        lean
                                        fa
                                        b
                                        _clearme0
                                        lebn
                                        fb
                                        __
                                        injf
                                        auto))
                                  b
                                  auto)
                               (f a)
                               (permutation.let_clause_1068
                                  f
                                  n
                                  permf
                                  i
                                  j
                                  lein
                                  lejn
                                  a
                                  _clearme
                                  lean
                                  fa
                                  b
                                  _clearme0
                                  lebn
                                  fb
                                  __
                                  injf
                                  auto))
                            (permutation.invert_permut n f (f b))
                            (permutation.invert_permut_f f n b lebn injf))
                         (permutation.invert_permut n f (f a))
                         (permutation.invert_permut_f f n a lean injf))
                      j
                      fb)
                   i
                   fa)
                permf)
             _clearme0)
          (permutation.permut_to_bijn n f permf j lejn))
       _clearme)
    (permutation.permut_to_bijn n f permf i lein).

def permut_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permutation.permut x x0)
             (x1:(cts.Term cts.star (permutation.permut x x0)) =>
              permutation.permut (permutation.invert_permut x0 x) x0))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  permf:(cts.Term
           cts.star
           (connectives.And
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (nat.le x n)
                    (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
              (permutation.injn f n))) =>
  connectives.conj
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x0:(cts.Term cts.star (nat.le x n)) => nat.le (permutation.invert_permut n f x) n)))
    (permutation.injn (permutation.invert_permut n f) n)
    (i:(cts.Term cts.box nat.nat) =>
     lein:(cts.Term cts.star (nat.le i n)) =>
     nat.nat_ind
       (_x_365:(cts.Term cts.box nat.nat) => nat.le (permutation.invert_permut _x_365 f i) _x_365)
       (permutation.sym_eq_invert_permut
          nat.O
          (y:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) => nat.nat))
                   (x0:(cts.Term
                          cts.box
                          (cts.prod
                             cts.box
                             cts.box
                             cts.box
                             cts.I
                             nat.nat
                             (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                    cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
           nat.le (y f i) nat.O)
          (nat.sym_eq_filter_nat_type_O
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))
                (x:(cts.Term
                      cts.box
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             (y:(cts.Term
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))
                      (x:(cts.Term
                            cts.box
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                       cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
              nat.le (y f i) nat.O)
             (permutation.sym_eq_invert_permut_body_O
                (y:(cts.Term
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         (cts.prod'
                            cts.box
                            cts.box
                            cts.box
                            nat.nat
                            (x:(cts.Term cts.box nat.nat) => nat.nat))
                         (x:(cts.Term
                               cts.box
                               (cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                          cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
                 nat.le (y f i) nat.O)
                (bool.match_bool_prop
                   (__:(cts.Term cts.box bool.bool) =>
                    nat.le (bool.match_bool_type nat.nat nat.O nat.O __) nat.O)
                   (bool.eq_match_bool_type_true
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term cts.box nat.nat) =>
                       nat.le (bool.match_bool_type nat.nat nat.O nat.O bool.true) y)
                      (nat.le_n (bool.match_bool_type nat.nat nat.O nat.O bool.true)))
                   (bool.eq_match_bool_type_false
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term cts.box nat.nat) =>
                       nat.le (bool.match_bool_type nat.nat nat.O nat.O bool.false) y)
                      (nat.le_n (bool.match_bool_type nat.nat nat.O nat.O bool.false)))
                   (nat.eqb i (f nat.O))))))
       (n1:(cts.Term cts.box nat.nat) =>
        permutation.sym_eq_invert_permut
          (nat.S n1)
          (y:(cts.Term
                cts.box
                (cts.prod'
                   cts.box
                   cts.box
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) => nat.nat))
                   (x0:(cts.Term
                          cts.box
                          (cts.prod
                             cts.box
                             cts.box
                             cts.box
                             cts.I
                             nat.nat
                             (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                    cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le (permutation.invert_permut n1 f i) n1)
             (x:(cts.Term cts.star (nat.le (permutation.invert_permut n1 f i) n1)) =>
              nat.le (y f i) (nat.S n1)))
          (nat.sym_eq_filter_nat_type_S
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) => nat.nat))
                (x:(cts.Term
                      cts.box
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                 cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) => nat.nat)))
             permutation.invert_permut_body
             n1
             (y:(cts.Term
                   cts.box
                   (cts.prod'
                      cts.box
                      cts.box
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         nat.nat
                         (x:(cts.Term cts.box nat.nat) => nat.nat))
                      (x:(cts.Term
                            cts.box
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
                       cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x0:(cts.Term cts.box nat.nat) => nat.nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le (permutation.invert_permut n1 f i) n1)
                (x:(cts.Term cts.star (nat.le (permutation.invert_permut n1 f i) n1)) =>
                 nat.le (y f i) (nat.S n1)))
             (permutation.sym_eq_invert_permut_body_S
                n1
                (y:(cts.Term
                      cts.box
                      (cts.prod'
                         cts.box
                         cts.box
                         cts.box
                         (cts.prod'
                            cts.box
                            cts.box
                            cts.box
                            nat.nat
                            (x0:(cts.Term cts.box nat.nat) => nat.nat))
                         (x0:(cts.Term
                                cts.box
                                (cts.prod
                                   cts.box
                                   cts.box
                                   cts.box
                                   cts.I
                                   nat.nat
                                   (x0:(cts.Term cts.box nat.nat) => nat.nat))) =>
                          cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x1:(cts.Term cts.box nat.nat) => nat.nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le (permutation.invert_permut n1 f i) n1)
                   (x:(cts.Term cts.star (nat.le (permutation.invert_permut n1 f i) n1)) =>
                    nat.le (y f i) (nat.S n1)))
                (Hind:(cts.Term cts.star (nat.le (permutation.invert_permut n1 f i) n1)) =>
                 bool.match_bool_prop
                   (__:(cts.Term cts.box bool.bool) =>
                    nat.le
                      (bool.match_bool_type
                         nat.nat
                         (nat.S n1)
                         (permutation.invert_permut n1 f i)
                         __)
                      (nat.S n1))
                   (bool.eq_match_bool_type_true
                      nat.nat
                      (nat.S n1)
                      (permutation.invert_permut n1 f i)
                      (y:(cts.Term cts.box nat.nat) =>
                       nat.le
                         (bool.match_bool_type
                            nat.nat
                            (nat.S n1)
                            (permutation.invert_permut n1 f i)
                            bool.true)
                         y)
                      (nat.le_n
                         (bool.match_bool_type
                            nat.nat
                            (nat.S n1)
                            (permutation.invert_permut n1 f i)
                            bool.true)))
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      (nat.S n1)
                      (permutation.invert_permut n1 f i)
                      (y:(cts.Term cts.box nat.nat) => nat.le y (nat.S n1))
                      (nat.le_S (permutation.invert_permut n1 f i) n1 Hind))
                   (nat.eqb i (f (nat.S n1)))))))
       n)
    (permutation.injective_invert_permut f n permf).

def f_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))
       (x:(cts.Term
             cts.box
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x1 x0)
                (x2:(cts.Term cts.star (nat.le x1 x0)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permutation.permut x x0)
                   (x3:(cts.Term cts.star (permutation.permut x x0)) =>
                    logic.eq nat.nat (x (permutation.invert_permut x0 x x1)) x1))))))
  :=
  f:(cts.Term
       cts.box
       (cts.prod' cts.box cts.box cts.box nat.nat (x:(cts.Term cts.box nat.nat) => nat.nat))) =>
  n:(cts.Term cts.box nat.nat) =>
  m:(cts.Term cts.box nat.nat) =>
  lemn:(cts.Term cts.star (nat.le m n)) =>
  permf:(cts.Term
           cts.star
           (connectives.And
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x:(cts.Term cts.box nat.nat) =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (nat.le x n)
                    (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
              (permutation.injn f n))) =>
  connectives.match_And_prop
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x0:(cts.Term cts.star (nat.le x n)) => nat.le (permutation.invert_permut n f x) n)))
    (permutation.injn (permutation.invert_permut n f) n)
    (logic.eq nat.nat (f (permutation.invert_permut n f m)) m)
    (Hle:(cts.Term
            cts.star
            (cts.prod'
               cts.box
               cts.star
               cts.star
               nat.nat
               (x:(cts.Term cts.box nat.nat) =>
                cts.prod
                  cts.star
                  cts.star
                  cts.star
                  cts.I
                  (nat.le x n)
                  (x0:(cts.Term cts.star (nat.le x n)) =>
                   nat.le (permutation.invert_permut n f x) n)))) =>
     Hinj:(cts.Term
             cts.star
             (cts.prod'
                cts.box
                cts.star
                cts.star
                nat.nat
                (x:(cts.Term cts.box nat.nat) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x0:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x n)
                      (x1:(cts.Term cts.star (nat.le x n)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x0 n)
                         (x2:(cts.Term cts.star (nat.le x0 n)) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq
                               nat.nat
                               (permutation.invert_permut n f x)
                               (permutation.invert_permut n f x0))
                            (x3:(cts.Term
                                   cts.star
                                   (logic.eq
                                      nat.nat
                                      (permutation.invert_permut n f x)
                                      (permutation.invert_permut n f x0))) =>
                             logic.eq nat.nat x x0))))))) =>
     connectives.match_And_prop
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x n)
             (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))
       (permutation.injn f n)
       (logic.eq nat.nat (f (permutation.invert_permut n f m)) m)
       (lef:(cts.Term
               cts.star
               (cts.prod'
                  cts.box
                  cts.star
                  cts.star
                  nat.nat
                  (x:(cts.Term cts.box nat.nat) =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (nat.le x n)
                     (x0:(cts.Term cts.star (nat.le x n)) => nat.le (f x) n)))) =>
        injf:(cts.Term
                cts.star
                (cts.prod'
                   cts.box
                   cts.star
                   cts.star
                   nat.nat
                   (x:(cts.Term cts.box nat.nat) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat.nat
                      (x0:(cts.Term cts.box nat.nat) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x n)
                         (x1:(cts.Term cts.star (nat.le x n)) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x0 n)
                            (x2:(cts.Term cts.star (nat.le x0 n)) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat.nat (f x) (f x0))
                               (x3:(cts.Term cts.star (logic.eq nat.nat (f x) (f x0))) =>
                                logic.eq nat.nat x x0))))))) =>
        permutation.injective_invert_permut
          f
          n
          permf
          (f (permutation.invert_permut n f m))
          m
          (lef (permutation.invert_permut n f m) (Hle m lemn))
          lemn
          (permutation.invert_permut_f f n (permutation.invert_permut n f m) (Hle m lemn) injf))
       permf)
    (permutation.permut_invert_permut f n permf).

